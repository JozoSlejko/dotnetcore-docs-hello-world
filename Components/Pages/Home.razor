@page "/"
@using System.Net.Http.Headers
@using System.Net.Http.Json
@inject IHttpClientFactory HttpClientFactory
@inject IHttpContextAccessor HttpContextAccessor

<PageTitle>Home</PageTitle>

<h1>Welcome to AVD!</h1>

<p style="margin-top: 1rem;">
    <a href="/.auth/login/aad">Login with Microsoft Entra (WIP)</a>
</p>

<p style="margin-top: 0.75rem;">
    <a href="/.auth/login/slejcooidc">Login with custom OIDC</a>
</p>

@if (_hasEmail)
{
    <p style="margin-top: 1rem;">
        <a href="@WindowsCloudUrl" target="_blank" rel="noopener noreferrer">
            Open AVD Application
        </a>
    </p>

    <p style="margin-top: 2rem;">
        <a href="/logout">
            Logout
        </a>
    </p>
}

@code {
    private const string EmailAddressClaimType =
        "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress";

    private const string WindowsCloudBaseUrl =
        "https://windows.cloud.microsoft/webclient/avd/d8817eb0-d704-4641-a3dd-70025b07ae56/6d754f78-afdd-4add-2e7a-08de563eb0a1?tenant=2244edc1-992d-4046-ac5a-c1a5250f6a42";

    private bool _hasEmail;
    private string WindowsCloudUrl { get; set; } = WindowsCloudBaseUrl;

    protected override async Task OnInitializedAsync()
    {
        await RefreshFromAuthMeWithRetryAsync();
    }

    private async Task RefreshFromAuthMeWithRetryAsync()
    {
        const int maxAttempts = 12;

        for (var attempt = 1; attempt <= maxAttempts; attempt++)
        {
            if (await TryRefreshFromAuthMeAsync())
                break;

            await Task.Delay(250);
        }
    }

    private async Task<bool> TryRefreshFromAuthMeAsync()
    {
        try
        {
            using var request = new HttpRequestMessage(HttpMethod.Get, "/.auth/me");

            // Forward the browser's cookies to the server-side call
            var cookieHeader = HttpContextAccessor.HttpContext?.Request.Headers.Cookie.ToString();
            if (!string.IsNullOrWhiteSpace(cookieHeader))
            {
                request.Headers.TryAddWithoutValidation("Cookie", cookieHeader);
            }

            var http = HttpClientFactory.CreateClient();

            // Ensure absolute URL (server-side HttpClient can't use relative URLs reliably)
            var req = HttpContextAccessor.HttpContext?.Request;
            if (req is not null)
            {
                http.BaseAddress = new Uri($"{req.Scheme}://{req.Host}");
            }

            var response = await http.SendAsync(request);
            if (!response.IsSuccessStatusCode)
            {
                _hasEmail = false;
                WindowsCloudUrl = WindowsCloudBaseUrl;
                return false;
            }

            var auth = await response.Content.ReadFromJsonAsync<AuthMeResponse[]>();

            var claims = auth?.FirstOrDefault()?.user_claims;

            var email = claims?
                .FirstOrDefault(c => c.typ == EmailAddressClaimType)
                ?.val;

            if (string.IsNullOrWhiteSpace(email))
            {
                _hasEmail = false;
                WindowsCloudUrl = WindowsCloudBaseUrl;
                return false;
            }

            // Extract domain from email for domain_hint (part after '@')
            var atIndex = email.IndexOf('@');
            var domain = atIndex >= 0 && atIndex < email.Length - 1
                ? email[(atIndex + 1)..]
                : string.Empty;

            _hasEmail = true;

            // Add domain_hint as a query parameter and keep loginHint in the fragment #loginHint={Uri.EscapeDataString(email)}
            WindowsCloudUrl =
                $"{WindowsCloudBaseUrl}&domain_hint={Uri.EscapeDataString(domain)}";

            return true;
        }
        catch
        {
            _hasEmail = false;
            WindowsCloudUrl = WindowsCloudBaseUrl;
            return false;
        }
        finally
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private sealed class AuthMeResponse
    {
        public ClaimItem[]? user_claims { get; set; }
    }

    private sealed class ClaimItem
    {
        public string? typ { get; set; }
        public string? val { get; set; }
    }
}
